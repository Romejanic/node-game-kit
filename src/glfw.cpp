/*
 * ====================== WARNING ========================
 * This file is (mostly) autogenerated. It should NOT be edited
 * unless there are errors to fix or something has gone wrong.
 * 
 * Instead, you should run:
 *  npm run gen-src
 * 
 * to automatically regenerate this file based on the associated
 * header file.
 */

#include <config.h>
#include <native-helper.h>
#include <GLFW/glfw3.h>

//==========================STRUCTS==========================//
#pragma region
v8::Local<v8::Object> _fromGLFWvidmode(const GLFWvidmode* arg) {
	v8::Isolate* isolate = v8::Isolate::GetCurrent();
	v8::Local<v8::Object> ret = v8::Object::New(isolate);
	ret->Set(TO_STRING("width"), TO_NUMBER(arg->width));
	ret->Set(TO_STRING("height"), TO_NUMBER(arg->height));
	ret->Set(TO_STRING("redBits"), TO_NUMBER(arg->redBits));
	ret->Set(TO_STRING("greenBits"), TO_NUMBER(arg->greenBits));
	ret->Set(TO_STRING("blueBits"), TO_NUMBER(arg->blueBits));
	ret->Set(TO_STRING("refreshRate"), TO_NUMBER(arg->refreshRate));
	return ret;
}
GLFWgammaramp* _toGLFWgammaramp(v8::Local<v8::Object> arg) {
	v8::Isolate* isolate = arg->GetIsolate();
	GLFWgammaramp* ret = (GLFWgammaramp*)malloc(sizeof(GLFWgammaramp));
	v8::Local<v8::String> redKey = TO_STRING("red");
	v8::Local<v8::String> greenKey = TO_STRING("green");
	v8::Local<v8::String> blueKey = TO_STRING("blue");
	if(!arg->Get(redKey)->IsUint16Array()) { free(&ret); THROW_TYPE_ERROR("GLFWgammaramp.red is of type Uint16Array!"); }
	if(!arg->Get(greenKey)->IsUint16Array()) { free(&ret); THROW_TYPE_ERROR("GLFWgammaramp.green is of type Uint16Array!"); }
	if(!arg->Get(blueKey)->IsUint16Array()) { free(&ret); THROW_TYPE_ERROR("GLFWgammaramp.blue is of type Uint16Array!"); }
	ret->red = static_cast<unsigned short*>(arg->Get(redKey).As<v8::Uint8Array>()->Buffer()->GetContents().Data());
	ret->green = static_cast<unsigned short*>(arg->Get(greenKey).As<v8::Uint8Array>()->Buffer()->GetContents().Data());
	ret->blue = static_cast<unsigned short*>(arg->Get(blueKey).As<v8::Uint8Array>()->Buffer()->GetContents().Data());
	ret->size = arg->Get(TO_STRING("size"))->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	return ret;
}
v8::Local<v8::Object> _fromGLFWgammaramp(const GLFWgammaramp* arg) {
	v8::Isolate* isolate = v8::Isolate::GetCurrent();
	v8::Local<v8::Object> ret = v8::Object::New(isolate);
	v8::Local<v8::ArrayBuffer> redArr = v8::ArrayBuffer::New(isolate, arg->red, arg->size * sizeof(unsigned short));
	v8::Local<v8::ArrayBuffer> greenArr = v8::ArrayBuffer::New(isolate, arg->green, arg->size * sizeof(unsigned short));
	v8::Local<v8::ArrayBuffer> blueArr = v8::ArrayBuffer::New(isolate, arg->blue, arg->size * sizeof(unsigned short));
	ret->Set(TO_STRING("red"), v8::Uint16Array::New(redArr, 0, arg->size));
	ret->Set(TO_STRING("green"), v8::Uint16Array::New(greenArr, 0, arg->size));
	ret->Set(TO_STRING("blue"), v8::Uint16Array::New(blueArr, 0, arg->size));
	ret->Set(TO_STRING("size"), TO_NUMBER(arg->size));
	return ret;
}
bool _toGLFWimage(GLFWimage* ret, v8::Local<v8::Object> arg) {
	v8::Isolate* isolate = arg->GetIsolate();
	ret->width = arg->Get(TO_STRING("width"))->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	ret->height = arg->Get(TO_STRING("height"))->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	v8::Local<v8::String> pixelKey = TO_STRING("pixels");
	if(!arg->Get(pixelKey)->IsUint8Array()) return false;
	v8::Local<v8::Uint8Array> pixelArr = arg->Get(pixelKey).As<v8::Uint8Array>();
	if(!pixelArr->Length() != ret->width * ret->height * 4) return false;
	uint8_t* data = static_cast<uint8_t*>(pixelArr->Buffer()->GetContents().Data());
	for(int i = 0; i < pixelArr->Length(); i++) {
		ret->pixels[i] = data[i];
	}
	return true;
}
v8::Local<v8::Object> _fromGLFWgamepadstate(const GLFWgamepadstate* arg) {
	v8::Isolate* isolate = v8::Isolate::GetCurrent();
	v8::Local<v8::Object> ret = v8::Object::New(isolate);
	v8::Local<v8::Array> buttonsArr = v8::Array::New(isolate, 15);
	for(int i = 0; i < 15; i++) {
		buttonsArr->Set(i, TO_NUMBER(arg->buttons[i]));
	}
	ret->Set(TO_STRING("buttons"), buttonsArr);
	v8::Local<v8::Array> axesArr = v8::Array::New(isolate, 6);
	for(int i = 0; i < 6; i++) {
		axesArr->Set(i, TO_NUMBER(arg->axes[i]));
	}
	ret->Set(TO_STRING("axes"), axesArr);
	return ret;
}

#pragma endregion

//==========================METHODS==========================//
#pragma region
NATIVE_FUNCTION(Init) {
	v8::Isolate* isolate = args.GetIsolate();
	int ret = glfwInit();
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(Terminate) {
	glfwTerminate();
}
NATIVE_FUNCTION(InitHint) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("InitHint takes 2 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("hint is of type number!"); }
	int hint = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("value is of type number!"); }
	int value = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwInitHint(hint, value);
}
NATIVE_FUNCTION(GetVersion) {
	v8::Isolate* isolate = args.GetIsolate();
	v8::Local<v8::Array> arr = v8::Array::New(isolate, 3);
	int major, minor, rev;
	glfwGetVersion(&major, &minor, &rev);
	arr->Set(0, TO_NUMBER(major));
	arr->Set(1, TO_NUMBER(minor));
	arr->Set(2, TO_NUMBER(rev));
	RETURN(arr);
}
NATIVE_FUNCTION(GetVersionString) {
	v8::Isolate* isolate = args.GetIsolate();
	const char* ret = glfwGetVersionString();
	RETURN(TO_STRING(ret));
}
NATIVE_FUNCTION(GetError) {
	v8::Isolate* isolate = args.GetIsolate();
	const char* desc;
	int ret = glfwGetError(&desc);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("code"), TO_NUMBER(ret));
	obj->Set(TO_STRING("desc"), TO_STRING(desc));
	RETURN(obj);
}
NATIVE_FUNCTION(SetErrorCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("SetErrorCallback takes 1 arguments."); }
	//!UNKNOWN TYPE for callback (type: 'GLFWerrorfun')!//
	// glfwSetErrorCallback(callback);
	THROW_ERROR("Not implemented"); // TODO
}
NATIVE_FUNCTION(GetMonitors) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetMonitors takes 1 arguments."); }
	int count;
	GLFWmonitor** ret = glfwGetMonitors(&count);
	v8::Local<v8::Array> arr = v8::Array::New(isolate, count);
	for(int i = 0; i < count; i++) {
		arr->Set(i, TO_NUMBER((uint64_t)ret[i]));
	}
	RETURN(arr);
}
NATIVE_FUNCTION(GetPrimaryMonitor) {
	v8::Isolate* isolate = args.GetIsolate();
	GLFWmonitor* ret = glfwGetPrimaryMonitor();
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(GetMonitorPos) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetMonitorPos takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	int xpos, ypos;
	glfwGetMonitorPos(monitor, &xpos, &ypos);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("xpos"), TO_NUMBER(xpos));
	obj->Set(TO_STRING("ypos"), TO_NUMBER(ypos));
	RETURN(obj);
}
NATIVE_FUNCTION(GetMonitorWorkarea) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetMonitorWorkarea takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	int xpos, ypos, width, height;
	glfwGetMonitorWorkarea(monitor, &xpos, &ypos, &width, &height);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("xpos"), TO_NUMBER(xpos));
	obj->Set(TO_STRING("ypos"), TO_NUMBER(ypos));
	obj->Set(TO_STRING("width"), TO_NUMBER(width));
	obj->Set(TO_STRING("height"), TO_NUMBER(height));
	RETURN(obj);
}
NATIVE_FUNCTION(GetMonitorPhysicalSize) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetMonitorPhysicalSize takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	int widthMM, heightMM;
	glfwGetMonitorPhysicalSize(monitor, &widthMM, &heightMM);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("widthMM"), TO_NUMBER(widthMM));
	obj->Set(TO_STRING("heightMM"), TO_NUMBER(heightMM));
	RETURN(obj);
}
NATIVE_FUNCTION(GetMonitorContentScale) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetMonitorContentScale takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	float xscale, yscale;
	glfwGetMonitorContentScale(monitor, &xscale, &yscale);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("xscale"), TO_NUMBER(xscale));
	obj->Set(TO_STRING("yscale"), TO_NUMBER(yscale));
	RETURN(obj);
}
NATIVE_FUNCTION(GetMonitorName) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetMonitorName takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	const char* ret = glfwGetMonitorName(monitor);
	RETURN(TO_STRING(ret));
}
NATIVE_FUNCTION(SetMonitorUserPointer) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetMonitorUserPointer takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber() && !args[1]->IsNullOrUndefined()) { THROW_TYPE_ERROR("pointer is of type pointer!"); }
	void* pointer;
	if(args[1]->IsNullOrUndefined()) { pointer = NULL; }
	else { pointer = reinterpret_cast<void*>(args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwSetMonitorUserPointer(monitor, pointer);
}
NATIVE_FUNCTION(GetMonitorUserPointer) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetMonitorUserPointer takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	void* ret = glfwGetMonitorUserPointer(monitor);
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(SetMonitorCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("SetMonitorCallback takes 1 arguments."); }
	//!UNKNOWN TYPE for callback (type: 'GLFWmonitorfun')!//
	// glfwSetMonitorCallback(callback);
	THROW_ERROR("Not implemented"); // TODO
}
NATIVE_FUNCTION(GetVideoModes) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetVideoModes takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	int count;
	const GLFWvidmode* ret = glfwGetVideoModes(monitor, &count);
	v8::Local<v8::Array> arr = v8::Array::New(isolate, count);
	for(int i = 0; i < count; i++) {
		arr->Set(i, _fromGLFWvidmode(&ret[i]));
	}
	RETURN(arr);
}
NATIVE_FUNCTION(GetVideoMode) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetVideoMode takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	const GLFWvidmode* ret = glfwGetVideoMode(monitor);
	RETURN(_fromGLFWvidmode(ret));
}
NATIVE_FUNCTION(SetGamma) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetGamma takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("gamma is of type number!"); }
	float gamma = args[1]->NumberValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetGamma(monitor, gamma);
}
NATIVE_FUNCTION(GetGammaRamp) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetGammaRamp takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	const GLFWgammaramp* ret = glfwGetGammaRamp(monitor);
	RETURN(_fromGLFWgammaramp(ret));
}
NATIVE_FUNCTION(SetGammaRamp) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetGammaRamp takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[0]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsObject()) { THROW_TYPE_ERROR("ramp is of type object!"); }
	const GLFWgammaramp* ramp = _toGLFWgammaramp(args[1]);
	glfwSetGammaRamp(monitor, ramp);
	free(&ramp); // free allocated GLFWgammaramp in _toGLFWgammaramp()
}
NATIVE_FUNCTION(DefaultWindowHints) {
	glfwDefaultWindowHints();
}
NATIVE_FUNCTION(WindowHint) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("WindowHint takes 2 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("hint is of type number!"); }
	int hint = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("value is of type number!"); }
	int value = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwWindowHint(hint, value);
}
NATIVE_FUNCTION(WindowHintString) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("WindowHintString takes 2 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("hint is of type number!"); }
	int hint = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[1]->IsString()) { THROW_TYPE_ERROR("value is of type string!"); }
	const char* value = (const char*)(*v8::String::Utf8Value(isolate, args[1]));
	glfwWindowHintString(hint, value);
}
NATIVE_FUNCTION(CreateWindow) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 5) { THROW_ERROR("CreateWindow takes 5 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("width is of type number!"); }
	int width = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("height is of type number!"); }
	int height = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[2]->IsString()) { THROW_TYPE_ERROR("title is of type string!"); }
	const char* title = (const char*)(*v8::String::Utf8Value(isolate, args[2]));
	if(!args[3]->IsNumber() && !args[3]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[3]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[3]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[4]->IsNumber() && !args[4]->IsNullOrUndefined()) { THROW_TYPE_ERROR("share is of type pointer!"); }
	GLFWwindow* share;
	if(args[4]->IsNullOrUndefined()) { share = NULL; }
	else { share = reinterpret_cast<GLFWwindow*>(args[4]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	GLFWwindow* ret = glfwCreateWindow(width, height, title, monitor, share);
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(DestroyWindow) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("DestroyWindow takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwDestroyWindow(window);
}
NATIVE_FUNCTION(WindowShouldClose) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("WindowShouldClose takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	int ret = glfwWindowShouldClose(window);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(SetWindowShouldClose) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowShouldClose takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("value is of type number!"); }
	int value = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetWindowShouldClose(window, value);
}
NATIVE_FUNCTION(SetWindowTitle) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowTitle takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsString()) { THROW_TYPE_ERROR("title is of type string!"); }
	const char* title = (const char*)(*v8::String::Utf8Value(isolate, args[1]));
	glfwSetWindowTitle(window, title);
}
NATIVE_FUNCTION(SetWindowIcon) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowIcon takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsArray()) { THROW_TYPE_ERROR("images is of type array!"); }
	v8::Local<v8::Array> arr = args[1].As<v8::Array>();
	int count = arr->Length();
	GLFWimage* images = (GLFWimage*)malloc(sizeof(GLFWimage) * count);
	for(int i = 0; i < count; i++) {
		if(!arr->Get(i)->IsObject()) { free(&images); THROW_TYPE_ERROR("Each image in images should be an object!"); }
		v8::Local<v8::Object> imageObj = arr->Get(i).As<v8::Object>();
		if(!_toGLFWimage(&images[i], arr->Get(i))) {
			THROW_TYPE_ERROR("Error parsing GLFWimage object. Make sure the 'pixels' field is a Uint8Array and is width*height*4 in length.");
			images[i].width = 0;
			images[i].height = 0;
			images[i].pixels = NULL;
		}
	}
	glfwSetWindowIcon(window, count, images);
	free(&images);
}
NATIVE_FUNCTION(GetWindowPos) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetWindowPos takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	int xpos, ypos;
	glfwGetWindowPos(window, &xpos, &ypos);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("xpos"), TO_NUMBER(xpos));
	obj->Set(TO_STRING("ypos"), TO_NUMBER(ypos));
	RETURN(obj);
}
NATIVE_FUNCTION(SetWindowPos) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 3) { THROW_ERROR("SetWindowPos takes 3 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("xpos is of type number!"); }
	int xpos = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[2]->IsNumber()) { THROW_TYPE_ERROR("ypos is of type number!"); }
	int ypos = args[2]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetWindowPos(window, xpos, ypos);
}
NATIVE_FUNCTION(GetWindowSize) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetWindowSize takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	int width, height;
	glfwGetWindowSize(window, &width, &height);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("width"), TO_NUMBER(width));
	obj->Set(TO_STRING("height"), TO_NUMBER(height));
	RETURN(obj);
}
NATIVE_FUNCTION(SetWindowSizeLimits) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 5) { THROW_ERROR("SetWindowSizeLimits takes 5 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("minwidth is of type number!"); }
	int minwidth = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[2]->IsNumber()) { THROW_TYPE_ERROR("minheight is of type number!"); }
	int minheight = args[2]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[3]->IsNumber()) { THROW_TYPE_ERROR("maxwidth is of type number!"); }
	int maxwidth = args[3]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[4]->IsNumber()) { THROW_TYPE_ERROR("maxheight is of type number!"); }
	int maxheight = args[4]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetWindowSizeLimits(window, minwidth, minheight, maxwidth, maxheight);
}
NATIVE_FUNCTION(SetWindowAspectRatio) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 3) { THROW_ERROR("SetWindowAspectRatio takes 3 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("numer is of type number!"); }
	int numer = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[2]->IsNumber()) { THROW_TYPE_ERROR("denom is of type number!"); }
	int denom = args[2]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetWindowAspectRatio(window, numer, denom);
}
NATIVE_FUNCTION(SetWindowSize) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 3) { THROW_ERROR("SetWindowSize takes 3 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("width is of type number!"); }
	int width = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[2]->IsNumber()) { THROW_TYPE_ERROR("height is of type number!"); }
	int height = args[2]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetWindowSize(window, width, height);
}
NATIVE_FUNCTION(GetFramebufferSize) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetFramebufferSize takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	int width, height;
	glfwGetFramebufferSize(window, &width, &height);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("width"), TO_NUMBER(width));
	obj->Set(TO_STRING("height"), TO_NUMBER(height));
	RETURN(obj);
}
NATIVE_FUNCTION(GetWindowFrameSize) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetWindowFrameSize takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	int left, top, right, bottom;
	glfwGetWindowFrameSize(window, &left, &top, &right, &bottom);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("left"), TO_NUMBER(left));
	obj->Set(TO_STRING("top"), TO_NUMBER(top));
	obj->Set(TO_STRING("right"), TO_NUMBER(right));
	obj->Set(TO_STRING("bottom"), TO_NUMBER(bottom));
	RETURN(obj);
}
NATIVE_FUNCTION(GetWindowContentScale) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetWindowContentScale takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	float xscale, yscale;
	glfwGetWindowContentScale(window, &xscale, &yscale);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("xscale"), TO_NUMBER(xscale));
	obj->Set(TO_STRING("yscale"), TO_NUMBER(yscale));
	RETURN(obj);
}
NATIVE_FUNCTION(GetWindowOpacity) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetWindowOpacity takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	float ret = glfwGetWindowOpacity(window);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(SetWindowOpacity) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowOpacity takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("opacity is of type number!"); }
	float opacity = args[1]->NumberValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetWindowOpacity(window, opacity);
}
NATIVE_FUNCTION(IconifyWindow) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("IconifyWindow takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwIconifyWindow(window);
}
NATIVE_FUNCTION(RestoreWindow) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("RestoreWindow takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwRestoreWindow(window);
}
NATIVE_FUNCTION(MaximizeWindow) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("MaximizeWindow takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwMaximizeWindow(window);
}
NATIVE_FUNCTION(ShowWindow) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("ShowWindow takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwShowWindow(window);
}
NATIVE_FUNCTION(HideWindow) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("HideWindow takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwHideWindow(window);
}
NATIVE_FUNCTION(FocusWindow) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("FocusWindow takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwFocusWindow(window);
}
NATIVE_FUNCTION(RequestWindowAttention) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("RequestWindowAttention takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwRequestWindowAttention(window);
}
NATIVE_FUNCTION(GetWindowMonitor) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetWindowMonitor takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	GLFWmonitor* ret = glfwGetWindowMonitor(window);
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(SetWindowMonitor) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 7) { THROW_ERROR("SetWindowMonitor takes 7 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber() && !args[1]->IsNullOrUndefined()) { THROW_TYPE_ERROR("monitor is of type pointer!"); }
	GLFWmonitor* monitor;
	if(args[1]->IsNullOrUndefined()) { monitor = NULL; }
	else { monitor = reinterpret_cast<GLFWmonitor*>(args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[2]->IsNumber()) { THROW_TYPE_ERROR("xpos is of type number!"); }
	int xpos = args[2]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[3]->IsNumber()) { THROW_TYPE_ERROR("ypos is of type number!"); }
	int ypos = args[3]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[4]->IsNumber()) { THROW_TYPE_ERROR("width is of type number!"); }
	int width = args[4]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[5]->IsNumber()) { THROW_TYPE_ERROR("height is of type number!"); }
	int height = args[5]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[6]->IsNumber()) { THROW_TYPE_ERROR("refreshRate is of type number!"); }
	int refreshRate = args[6]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetWindowMonitor(window, monitor, xpos, ypos, width, height, refreshRate);
}
NATIVE_FUNCTION(GetWindowAttrib) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("GetWindowAttrib takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("attrib is of type number!"); }
	int attrib = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int ret = glfwGetWindowAttrib(window, attrib);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(SetWindowAttrib) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 3) { THROW_ERROR("SetWindowAttrib takes 3 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("attrib is of type number!"); }
	int attrib = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[2]->IsNumber()) { THROW_TYPE_ERROR("value is of type number!"); }
	int value = args[2]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetWindowAttrib(window, attrib, value);
}
NATIVE_FUNCTION(SetWindowUserPointer) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowUserPointer takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber() && !args[1]->IsNullOrUndefined()) { THROW_TYPE_ERROR("pointer is of type pointer!"); }
	void* pointer;
	if(args[1]->IsNullOrUndefined()) { pointer = NULL; }
	else { pointer = reinterpret_cast<void*>(args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwSetWindowUserPointer(window, pointer);
}
NATIVE_FUNCTION(GetWindowUserPointer) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetWindowUserPointer takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	void* ret = glfwGetWindowUserPointer(window);
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(SetWindowPosCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowPosCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWwindowposfun')!//
	// glfwSetWindowPosCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetWindowSizeCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowSizeCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWwindowsizefun')!//
	// glfwSetWindowSizeCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetWindowCloseCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowCloseCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWwindowclosefun')!//
	// glfwSetWindowCloseCallback(window, callback);
	THROW_ERROR("Not implemented"); // TODO
}
NATIVE_FUNCTION(SetWindowRefreshCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowRefreshCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWwindowrefreshfun')!//
	// glfwSetWindowRefreshCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetWindowFocusCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowFocusCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWwindowfocusfun')!//
	// glfwSetWindowFocusCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetWindowIconifyCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowIconifyCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWwindowiconifyfun')!//
	// glfwSetWindowIconifyCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetWindowMaximizeCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowMaximizeCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWwindowmaximizefun')!//
	// glfwSetWindowMaximizeCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetFramebufferSizeCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetFramebufferSizeCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWframebuffersizefun')!//
	// glfwSetFramebufferSizeCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetWindowContentScaleCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetWindowContentScaleCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWwindowcontentscalefun')!//
	// glfwSetWindowContentScaleCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(PollEvents) {
	glfwPollEvents();
}
NATIVE_FUNCTION(WaitEvents) {
	glfwWaitEvents();
}
NATIVE_FUNCTION(WaitEventsTimeout) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("WaitEventsTimeout takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("timeout is of type number!"); }
	double timeout = args[0]->NumberValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwWaitEventsTimeout(timeout);
}
NATIVE_FUNCTION(PostEmptyEvent) {
	glfwPostEmptyEvent();
}
NATIVE_FUNCTION(GetInputMode) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("GetInputMode takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("mode is of type number!"); }
	int mode = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int ret = glfwGetInputMode(window, mode);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(SetInputMode) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 3) { THROW_ERROR("SetInputMode takes 3 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("mode is of type number!"); }
	int mode = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[2]->IsNumber()) { THROW_TYPE_ERROR("value is of type number!"); }
	int value = args[2]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetInputMode(window, mode, value);
}
NATIVE_FUNCTION(RawMouseMotionSupported) {
	v8::Isolate* isolate = args.GetIsolate();
	int ret = glfwRawMouseMotionSupported();
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(GetKeyName) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("GetKeyName takes 2 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("key is of type number!"); }
	int key = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("scancode is of type number!"); }
	int scancode = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	const char* ret = glfwGetKeyName(key, scancode);
	RETURN(TO_STRING(ret));
}
NATIVE_FUNCTION(GetKeyScancode) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetKeyScancode takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("key is of type number!"); }
	int key = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int ret = glfwGetKeyScancode(key);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(GetKey) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("GetKey takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("key is of type number!"); }
	int key = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int ret = glfwGetKey(window, key);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(GetMouseButton) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("GetMouseButton takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("button is of type number!"); }
	int button = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int ret = glfwGetMouseButton(window, button);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(GetCursorPos) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetCursorPos takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	double xpos, ypos;
	glfwGetCursorPos(window, &xpos, &ypos);
	v8::Local<v8::Object> obj = v8::Object::New(isolate);
	obj->Set(TO_STRING("xpos"), TO_NUMBER(xpos));
	obj->Set(TO_STRING("ypos"), TO_NUMBER(ypos));
	RETURN(obj);
}
NATIVE_FUNCTION(SetCursorPos) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 3) { THROW_ERROR("SetCursorPos takes 3 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("xpos is of type number!"); }
	double xpos = args[1]->NumberValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[2]->IsNumber()) { THROW_TYPE_ERROR("ypos is of type number!"); }
	double ypos = args[2]->NumberValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetCursorPos(window, xpos, ypos);
}
NATIVE_FUNCTION(CreateCursor) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 3) { THROW_ERROR("CreateCursor takes 3 arguments."); }
	if(!args[0]->IsObject()) { THROW_TYPE_ERROR("image is of type object!"); }
	GLFWimage* image = (GLFWimage*)malloc(sizeof(GLFWimage));
	if(!_toGLFWimage(image, args[0]->ToObject(isolate->GetCurrentContext()).ToLocalChecked()) {
		free(&image);
		THROW_ERROR("Invalid image object!");
	}
	if(!args[1]->IsNumber()) { THROW_TYPE_ERROR("xhot is of type number!"); }
	int xhot = args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[2]->IsNumber()) { THROW_TYPE_ERROR("yhot is of type number!"); }
	int yhot = args[2]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	GLFWcursor* ret = glfwCreateCursor(image, xhot, yhot);
	free(&image);
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(CreateStandardCursor) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("CreateStandardCursor takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("shape is of type number!"); }
	int shape = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	GLFWcursor* ret = glfwCreateStandardCursor(shape);
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(DestroyCursor) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("DestroyCursor takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("cursor is of type pointer!"); }
	GLFWcursor* cursor;
	if(args[0]->IsNullOrUndefined()) { cursor = NULL; }
	else { cursor = reinterpret_cast<GLFWcursor*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwDestroyCursor(cursor);
}
NATIVE_FUNCTION(SetCursor) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetCursor takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsNumber() && !args[1]->IsNullOrUndefined()) { THROW_TYPE_ERROR("cursor is of type pointer!"); }
	GLFWcursor* cursor;
	if(args[1]->IsNullOrUndefined()) { cursor = NULL; }
	else { cursor = reinterpret_cast<GLFWcursor*>(args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwSetCursor(window, cursor);
}
NATIVE_FUNCTION(SetKeyCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetKeyCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWkeyfun')!//
	// glfwSetKeyCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetCharCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetCharCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWcharfun')!//
	// glfwSetCharCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetCharModsCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetCharModsCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWcharmodsfun')!//
	// glfwSetCharModsCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetMouseButtonCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetMouseButtonCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWmousebuttonfun')!//
	// glfwSetMouseButtonCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetCursorPosCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetCursorPosCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWcursorposfun')!//
	// glfwSetCursorPosCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetCursorEnterCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetCursorEnterCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWcursorenterfun')!//
	// glfwSetCursorEnterCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetScrollCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetScrollCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWscrollfun')!//
	// glfwSetScrollCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(SetDropCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetDropCallback takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	//!UNKNOWN TYPE for callback (type: 'GLFWdropfun')!//
	// glfwSetDropCallback(window, callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(JoystickPresent) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("JoystickPresent takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int ret = glfwJoystickPresent(jid);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(GetJoystickAxes) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetJoystickAxes takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int count;
	const float* ret = glfwGetJoystickAxes(jid, &count);
	v8::Local<v8::Array> arr = v8::Array::New(isolate, count);
	for(int i = 0; i < count; i++) {
		arr->Set(i, TO_NUMBER(ret[i]));
	}
	RETURN(arr);
}
NATIVE_FUNCTION(GetJoystickButtons) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetJoystickButtons takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int count;
	const unsigned char* ret = glfwGetJoystickButtons(jid, &count);
	v8::Local<v8::Array> arr = v8::Array::New(isolate, count);
	for(int i = 0; i < count; i++) {
		arr->Set(i, TO_NUMBER(ret[i]));
	}
	RETURN(arr);
}
NATIVE_FUNCTION(GetJoystickHats) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetJoystickHats takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int count;
	const unsigned char* ret = glfwGetJoystickHats(jid, &count);
	v8::Local<v8::Array> arr = v8::Array::New(isolate, count);
	for(int i = 0; i < count; i++) {
		arr->Set(i, TO_NUMBER(ret[i]));
	}
	RETURN(arr);
}
NATIVE_FUNCTION(GetJoystickName) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetJoystickName takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	const char* ret = glfwGetJoystickName(jid);
	RETURN(TO_STRING(ret));
}
NATIVE_FUNCTION(GetJoystickGUID) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetJoystickGUID takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	const char* ret = glfwGetJoystickGUID(jid);
	RETURN(TO_STRING(ret));
}
NATIVE_FUNCTION(SetJoystickUserPointer) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetJoystickUserPointer takes 2 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	if(!args[1]->IsNumber() && !args[1]->IsNullOrUndefined()) { THROW_TYPE_ERROR("pointer is of type pointer!"); }
	void* pointer;
	if(args[1]->IsNullOrUndefined()) { pointer = NULL; }
	else { pointer = reinterpret_cast<void*>(args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwSetJoystickUserPointer(jid, pointer);
}
NATIVE_FUNCTION(GetJoystickUserPointer) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetJoystickUserPointer takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	void* ret = glfwGetJoystickUserPointer(jid);
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(JoystickIsGamepad) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("JoystickIsGamepad takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	int ret = glfwJoystickIsGamepad(jid);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(SetJoystickCallback) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("SetJoystickCallback takes 1 arguments."); }
	//!UNKNOWN TYPE for callback (type: 'GLFWjoystickfun')!//
	// glfwSetJoystickCallback(callback);
	THROW_ERROR("Not implemented."); // TODO
}
NATIVE_FUNCTION(UpdateGamepadMappings) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("UpdateGamepadMappings takes 1 arguments."); }
	if(!args[0]->IsString()) { THROW_TYPE_ERROR("string is of type string!"); }
	const char* string = (const char*)(*v8::String::Utf8Value(isolate, args[0]));
	int ret = glfwUpdateGamepadMappings(string);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(GetGamepadName) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetGamepadName takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	const char* ret = glfwGetGamepadName(jid);
	RETURN(TO_STRING(ret));
}
NATIVE_FUNCTION(GetGamepadState) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("GetGamepadState takes 2 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("jid is of type number!"); }
	int jid = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	GLFWgamepadstate* state;
	if(!glfwGetGamepadState(jid, state)) {
		RETURN(TO_BOOLEAN(false));
	} else {
		RETURN(_fromGLFWgamepadstate(state));
	}
}
NATIVE_FUNCTION(SetClipboardString) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 2) { THROW_ERROR("SetClipboardString takes 2 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	if(!args[1]->IsString()) { THROW_TYPE_ERROR("string is of type string!"); }
	const char* string = (const char*)(*v8::String::Utf8Value(isolate, args[1]));
	glfwSetClipboardString(window, string);
}
NATIVE_FUNCTION(GetClipboardString) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetClipboardString takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	const char* ret = glfwGetClipboardString(window);
	RETURN(TO_STRING(ret));
}
NATIVE_FUNCTION(GetTime) {
	v8::Isolate* isolate = args.GetIsolate();
	double ret = glfwGetTime();
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(SetTime) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("SetTime takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("time is of type number!"); }
	double time = args[0]->NumberValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSetTime(time);
}
NATIVE_FUNCTION(GetTimerValue) {
	v8::Isolate* isolate = args.GetIsolate();
	uint64_t ret = glfwGetTimerValue();
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(GetTimerFrequency) {
	v8::Isolate* isolate = args.GetIsolate();
	uint64_t ret = glfwGetTimerFrequency();
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(MakeContextCurrent) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("MakeContextCurrent takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwMakeContextCurrent(window);
}
NATIVE_FUNCTION(GetCurrentContext) {
	v8::Isolate* isolate = args.GetIsolate();
	GLFWwindow* ret = glfwGetCurrentContext();
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(SwapBuffers) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("SwapBuffers takes 1 arguments."); }
	if(!args[0]->IsNumber() && !args[0]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	GLFWwindow* window;
	if(args[0]->IsNullOrUndefined()) { window = NULL; }
	else { window = reinterpret_cast<GLFWwindow*>(args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	glfwSwapBuffers(window);
}
NATIVE_FUNCTION(SwapInterval) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("SwapInterval takes 1 arguments."); }
	if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("interval is of type number!"); }
	int interval = args[0]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0);
	glfwSwapInterval(interval);
}
NATIVE_FUNCTION(ExtensionSupported) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("ExtensionSupported takes 1 arguments."); }
	if(!args[0]->IsString()) { THROW_TYPE_ERROR("extension is of type string!"); }
	const char* extension = (const char*)(*v8::String::Utf8Value(isolate, args[0]));
	int ret = glfwExtensionSupported(extension);
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(GetProcAddress) {
	v8::Isolate* isolate = args.GetIsolate();
	if(args.Length() < 1) { THROW_ERROR("GetProcAddress takes 1 arguments."); }
	if(!args[0]->IsString()) { THROW_TYPE_ERROR("procname is of type string!"); }
	const char* procname = (const char*)(*v8::String::Utf8Value(isolate, args[0]));
	GLFWglproc ret = glfwGetProcAddress(procname);
	RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(VulkanSupported) {
	v8::Isolate* isolate = args.GetIsolate();
	int ret = glfwVulkanSupported();
	RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(GetRequiredInstanceExtensions) {
	v8::Isolate* isolate = args.GetIsolate();
	uint32_t count;
	const char** ret = glfwGetRequiredInstanceExtensions(&count);
	v8::Local<v8::Array> arr = v8::Array::New(isolate, count);
	for(int i = 0; i < count; i++) {
		arr->Set(i, TO_STRING(ret[i]));
	}
	RETURN(arr);
}
NATIVE_FUNCTION(GetInstanceProcAddress) {
	v8::Isolate* isolate = args.GetIsolate();
	THROW_ERROR("Not implemented."); //TODO
	// if(args.Length() < 2) { THROW_ERROR("GetInstanceProcAddress takes 2 arguments."); }
	// if(!args[0]->IsNumber()) { THROW_TYPE_ERROR("instance is of type pointer!"); }
	// VkInstance instance;
	// if(!args[1]->IsString()) { THROW_TYPE_ERROR("procname is of type string!"); }
	// const char* procname = (const char*)(*v8::String::Utf8Value(args[1]));
	// GLFWvkproc ret = glfwGetInstanceProcAddress(instance, procname);
	// RETURN(TO_NUMBER((uint64_t)ret));
}
NATIVE_FUNCTION(GetPhysicalDevicePresentationSupport) {
	v8::Isolate* isolate = args.GetIsolate();
	THROW_ERROR("Not implemented."); //TODO
	// if(args.Length() < 3) { THROW_ERROR("GetPhysicalDevicePresentationSupport takes 3 arguments."); }
	// //!UNKNOWN TYPE for instance (type: 'VkInstance')!//
	// //!UNKNOWN TYPE for device (type: 'VkPhysicalDevice')!//
	// //!UNKNOWN TYPE for queuefamily (type: 'uint32_t')!//
	// int ret = glfwGetPhysicalDevicePresentationSupport(instance, device, queuefamily);
	// RETURN(TO_NUMBER(ret));
}
NATIVE_FUNCTION(CreateWindowSurface) {
	v8::Isolate* isolate = args.GetIsolate();
	THROW_ERROR("Not implemented."); //TODO
	// if(args.Length() < 4) { THROW_ERROR("CreateWindowSurface takes 4 arguments."); }
	// //!UNKNOWN TYPE for instance (type: 'VkInstance')!//
	// if(!args[1]->IsNumber() && !args[1]->IsNullOrUndefined()) { THROW_TYPE_ERROR("window is of type pointer!"); }
	// GLFWwindow* window;
	// if(args[1]->IsNullOrUndefined()) { window = NULL; }
	// else { window = reinterpret_cast<GLFWwindow*>(args[1]->IntegerValue(isolate->GetCurrentContext()).FromMaybe(0)); }
	// //!UNKNOWN TYPE for allocator (type: 'const VkAllocationCallbacks*')!//
	// //!UNKNOWN TYPE for surface (type: 'VkSurfaceKHR*')!//
	// VkResult ret = glfwCreateWindowSurface(instance, window, allocator, surface);
	// //!UNKNOWN RETURN TYPE for glfwCreateWindowSurface//
}

#pragma endregion

//==========================INIT==========================//

void ExportModule(v8::Local<v8::Object> exports) {
    v8::Isolate* isolate = exports->GetIsolate();
    // Consts
    #pragma region
	EXPORT_CONST("VERSION_MAJOR", GLFW_VERSION_MAJOR);
	EXPORT_CONST("VERSION_MINOR", GLFW_VERSION_MINOR);
	EXPORT_CONST("VERSION_REVISION", GLFW_VERSION_REVISION);
	EXPORT_CONST("TRUE", GLFW_TRUE);
	EXPORT_CONST("FALSE", GLFW_FALSE);
	EXPORT_CONST("RELEASE", GLFW_RELEASE);
	EXPORT_CONST("PRESS", GLFW_PRESS);
	EXPORT_CONST("REPEAT", GLFW_REPEAT);
	EXPORT_CONST("HAT_CENTERED", GLFW_HAT_CENTERED);
	EXPORT_CONST("HAT_UP", GLFW_HAT_UP);
	EXPORT_CONST("HAT_RIGHT", GLFW_HAT_RIGHT);
	EXPORT_CONST("HAT_DOWN", GLFW_HAT_DOWN);
	EXPORT_CONST("HAT_LEFT", GLFW_HAT_LEFT);
	EXPORT_CONST("HAT_RIGHT_UP", GLFW_HAT_RIGHT_UP);
	EXPORT_CONST("HAT_RIGHT_DOWN", GLFW_HAT_RIGHT_DOWN);
	EXPORT_CONST("HAT_LEFT_UP", GLFW_HAT_LEFT_UP);
	EXPORT_CONST("HAT_LEFT_DOWN", GLFW_HAT_LEFT_DOWN);
	EXPORT_CONST("KEY_UNKNOWN", GLFW_KEY_UNKNOWN);
	EXPORT_CONST("KEY_SPACE", GLFW_KEY_SPACE);
	EXPORT_CONST("KEY_APOSTROPHE", GLFW_KEY_APOSTROPHE);
	EXPORT_CONST("KEY_COMMA", GLFW_KEY_COMMA);
	EXPORT_CONST("KEY_MINUS", GLFW_KEY_MINUS);
	EXPORT_CONST("KEY_PERIOD", GLFW_KEY_PERIOD);
	EXPORT_CONST("KEY_SLASH", GLFW_KEY_SLASH);
	EXPORT_CONST("KEY_0", GLFW_KEY_0);
	EXPORT_CONST("KEY_1", GLFW_KEY_1);
	EXPORT_CONST("KEY_2", GLFW_KEY_2);
	EXPORT_CONST("KEY_3", GLFW_KEY_3);
	EXPORT_CONST("KEY_4", GLFW_KEY_4);
	EXPORT_CONST("KEY_5", GLFW_KEY_5);
	EXPORT_CONST("KEY_6", GLFW_KEY_6);
	EXPORT_CONST("KEY_7", GLFW_KEY_7);
	EXPORT_CONST("KEY_8", GLFW_KEY_8);
	EXPORT_CONST("KEY_9", GLFW_KEY_9);
	EXPORT_CONST("KEY_SEMICOLON", GLFW_KEY_SEMICOLON);
	EXPORT_CONST("KEY_EQUAL", GLFW_KEY_EQUAL);
	EXPORT_CONST("KEY_A", GLFW_KEY_A);
	EXPORT_CONST("KEY_B", GLFW_KEY_B);
	EXPORT_CONST("KEY_C", GLFW_KEY_C);
	EXPORT_CONST("KEY_D", GLFW_KEY_D);
	EXPORT_CONST("KEY_E", GLFW_KEY_E);
	EXPORT_CONST("KEY_F", GLFW_KEY_F);
	EXPORT_CONST("KEY_G", GLFW_KEY_G);
	EXPORT_CONST("KEY_H", GLFW_KEY_H);
	EXPORT_CONST("KEY_I", GLFW_KEY_I);
	EXPORT_CONST("KEY_J", GLFW_KEY_J);
	EXPORT_CONST("KEY_K", GLFW_KEY_K);
	EXPORT_CONST("KEY_L", GLFW_KEY_L);
	EXPORT_CONST("KEY_M", GLFW_KEY_M);
	EXPORT_CONST("KEY_N", GLFW_KEY_N);
	EXPORT_CONST("KEY_O", GLFW_KEY_O);
	EXPORT_CONST("KEY_P", GLFW_KEY_P);
	EXPORT_CONST("KEY_Q", GLFW_KEY_Q);
	EXPORT_CONST("KEY_R", GLFW_KEY_R);
	EXPORT_CONST("KEY_S", GLFW_KEY_S);
	EXPORT_CONST("KEY_T", GLFW_KEY_T);
	EXPORT_CONST("KEY_U", GLFW_KEY_U);
	EXPORT_CONST("KEY_V", GLFW_KEY_V);
	EXPORT_CONST("KEY_W", GLFW_KEY_W);
	EXPORT_CONST("KEY_X", GLFW_KEY_X);
	EXPORT_CONST("KEY_Y", GLFW_KEY_Y);
	EXPORT_CONST("KEY_Z", GLFW_KEY_Z);
	EXPORT_CONST("KEY_LEFT_BRACKET", GLFW_KEY_LEFT_BRACKET);
	EXPORT_CONST("KEY_BACKSLASH", GLFW_KEY_BACKSLASH);
	EXPORT_CONST("KEY_RIGHT_BRACKET", GLFW_KEY_RIGHT_BRACKET);
	EXPORT_CONST("KEY_GRAVE_ACCENT", GLFW_KEY_GRAVE_ACCENT);
	EXPORT_CONST("KEY_WORLD_1", GLFW_KEY_WORLD_1);
	EXPORT_CONST("KEY_WORLD_2", GLFW_KEY_WORLD_2);
	EXPORT_CONST("KEY_ESCAPE", GLFW_KEY_ESCAPE);
	EXPORT_CONST("KEY_ENTER", GLFW_KEY_ENTER);
	EXPORT_CONST("KEY_TAB", GLFW_KEY_TAB);
	EXPORT_CONST("KEY_BACKSPACE", GLFW_KEY_BACKSPACE);
	EXPORT_CONST("KEY_INSERT", GLFW_KEY_INSERT);
	EXPORT_CONST("KEY_DELETE", GLFW_KEY_DELETE);
	EXPORT_CONST("KEY_RIGHT", GLFW_KEY_RIGHT);
	EXPORT_CONST("KEY_LEFT", GLFW_KEY_LEFT);
	EXPORT_CONST("KEY_DOWN", GLFW_KEY_DOWN);
	EXPORT_CONST("KEY_UP", GLFW_KEY_UP);
	EXPORT_CONST("KEY_PAGE_UP", GLFW_KEY_PAGE_UP);
	EXPORT_CONST("KEY_PAGE_DOWN", GLFW_KEY_PAGE_DOWN);
	EXPORT_CONST("KEY_HOME", GLFW_KEY_HOME);
	EXPORT_CONST("KEY_END", GLFW_KEY_END);
	EXPORT_CONST("KEY_CAPS_LOCK", GLFW_KEY_CAPS_LOCK);
	EXPORT_CONST("KEY_SCROLL_LOCK", GLFW_KEY_SCROLL_LOCK);
	EXPORT_CONST("KEY_NUM_LOCK", GLFW_KEY_NUM_LOCK);
	EXPORT_CONST("KEY_PRINT_SCREEN", GLFW_KEY_PRINT_SCREEN);
	EXPORT_CONST("KEY_PAUSE", GLFW_KEY_PAUSE);
	EXPORT_CONST("KEY_F1", GLFW_KEY_F1);
	EXPORT_CONST("KEY_F2", GLFW_KEY_F2);
	EXPORT_CONST("KEY_F3", GLFW_KEY_F3);
	EXPORT_CONST("KEY_F4", GLFW_KEY_F4);
	EXPORT_CONST("KEY_F5", GLFW_KEY_F5);
	EXPORT_CONST("KEY_F6", GLFW_KEY_F6);
	EXPORT_CONST("KEY_F7", GLFW_KEY_F7);
	EXPORT_CONST("KEY_F8", GLFW_KEY_F8);
	EXPORT_CONST("KEY_F9", GLFW_KEY_F9);
	EXPORT_CONST("KEY_F10", GLFW_KEY_F10);
	EXPORT_CONST("KEY_F11", GLFW_KEY_F11);
	EXPORT_CONST("KEY_F12", GLFW_KEY_F12);
	EXPORT_CONST("KEY_F13", GLFW_KEY_F13);
	EXPORT_CONST("KEY_F14", GLFW_KEY_F14);
	EXPORT_CONST("KEY_F15", GLFW_KEY_F15);
	EXPORT_CONST("KEY_F16", GLFW_KEY_F16);
	EXPORT_CONST("KEY_F17", GLFW_KEY_F17);
	EXPORT_CONST("KEY_F18", GLFW_KEY_F18);
	EXPORT_CONST("KEY_F19", GLFW_KEY_F19);
	EXPORT_CONST("KEY_F20", GLFW_KEY_F20);
	EXPORT_CONST("KEY_F21", GLFW_KEY_F21);
	EXPORT_CONST("KEY_F22", GLFW_KEY_F22);
	EXPORT_CONST("KEY_F23", GLFW_KEY_F23);
	EXPORT_CONST("KEY_F24", GLFW_KEY_F24);
	EXPORT_CONST("KEY_F25", GLFW_KEY_F25);
	EXPORT_CONST("KEY_KP_0", GLFW_KEY_KP_0);
	EXPORT_CONST("KEY_KP_1", GLFW_KEY_KP_1);
	EXPORT_CONST("KEY_KP_2", GLFW_KEY_KP_2);
	EXPORT_CONST("KEY_KP_3", GLFW_KEY_KP_3);
	EXPORT_CONST("KEY_KP_4", GLFW_KEY_KP_4);
	EXPORT_CONST("KEY_KP_5", GLFW_KEY_KP_5);
	EXPORT_CONST("KEY_KP_6", GLFW_KEY_KP_6);
	EXPORT_CONST("KEY_KP_7", GLFW_KEY_KP_7);
	EXPORT_CONST("KEY_KP_8", GLFW_KEY_KP_8);
	EXPORT_CONST("KEY_KP_9", GLFW_KEY_KP_9);
	EXPORT_CONST("KEY_KP_DECIMAL", GLFW_KEY_KP_DECIMAL);
	EXPORT_CONST("KEY_KP_DIVIDE", GLFW_KEY_KP_DIVIDE);
	EXPORT_CONST("KEY_KP_MULTIPLY", GLFW_KEY_KP_MULTIPLY);
	EXPORT_CONST("KEY_KP_SUBTRACT", GLFW_KEY_KP_SUBTRACT);
	EXPORT_CONST("KEY_KP_ADD", GLFW_KEY_KP_ADD);
	EXPORT_CONST("KEY_KP_ENTER", GLFW_KEY_KP_ENTER);
	EXPORT_CONST("KEY_KP_EQUAL", GLFW_KEY_KP_EQUAL);
	EXPORT_CONST("KEY_LEFT_SHIFT", GLFW_KEY_LEFT_SHIFT);
	EXPORT_CONST("KEY_LEFT_CONTROL", GLFW_KEY_LEFT_CONTROL);
	EXPORT_CONST("KEY_LEFT_ALT", GLFW_KEY_LEFT_ALT);
	EXPORT_CONST("KEY_LEFT_SUPER", GLFW_KEY_LEFT_SUPER);
	EXPORT_CONST("KEY_RIGHT_SHIFT", GLFW_KEY_RIGHT_SHIFT);
	EXPORT_CONST("KEY_RIGHT_CONTROL", GLFW_KEY_RIGHT_CONTROL);
	EXPORT_CONST("KEY_RIGHT_ALT", GLFW_KEY_RIGHT_ALT);
	EXPORT_CONST("KEY_RIGHT_SUPER", GLFW_KEY_RIGHT_SUPER);
	EXPORT_CONST("KEY_MENU", GLFW_KEY_MENU);
	EXPORT_CONST("KEY_LAST", GLFW_KEY_LAST);
	EXPORT_CONST("MOD_SHIFT", GLFW_MOD_SHIFT);
	EXPORT_CONST("MOD_CONTROL", GLFW_MOD_CONTROL);
	EXPORT_CONST("MOD_ALT", GLFW_MOD_ALT);
	EXPORT_CONST("MOD_SUPER", GLFW_MOD_SUPER);
	EXPORT_CONST("MOD_CAPS_LOCK", GLFW_MOD_CAPS_LOCK);
	EXPORT_CONST("MOD_NUM_LOCK", GLFW_MOD_NUM_LOCK);
	EXPORT_CONST("MOUSE_BUTTON_1", GLFW_MOUSE_BUTTON_1);
	EXPORT_CONST("MOUSE_BUTTON_2", GLFW_MOUSE_BUTTON_2);
	EXPORT_CONST("MOUSE_BUTTON_3", GLFW_MOUSE_BUTTON_3);
	EXPORT_CONST("MOUSE_BUTTON_4", GLFW_MOUSE_BUTTON_4);
	EXPORT_CONST("MOUSE_BUTTON_5", GLFW_MOUSE_BUTTON_5);
	EXPORT_CONST("MOUSE_BUTTON_6", GLFW_MOUSE_BUTTON_6);
	EXPORT_CONST("MOUSE_BUTTON_7", GLFW_MOUSE_BUTTON_7);
	EXPORT_CONST("MOUSE_BUTTON_8", GLFW_MOUSE_BUTTON_8);
	EXPORT_CONST("MOUSE_BUTTON_LAST", GLFW_MOUSE_BUTTON_LAST);
	EXPORT_CONST("MOUSE_BUTTON_LEFT", GLFW_MOUSE_BUTTON_LEFT);
	EXPORT_CONST("MOUSE_BUTTON_RIGHT", GLFW_MOUSE_BUTTON_RIGHT);
	EXPORT_CONST("MOUSE_BUTTON_MIDDLE", GLFW_MOUSE_BUTTON_MIDDLE);
	EXPORT_CONST("JOYSTICK_1", GLFW_JOYSTICK_1);
	EXPORT_CONST("JOYSTICK_2", GLFW_JOYSTICK_2);
	EXPORT_CONST("JOYSTICK_3", GLFW_JOYSTICK_3);
	EXPORT_CONST("JOYSTICK_4", GLFW_JOYSTICK_4);
	EXPORT_CONST("JOYSTICK_5", GLFW_JOYSTICK_5);
	EXPORT_CONST("JOYSTICK_6", GLFW_JOYSTICK_6);
	EXPORT_CONST("JOYSTICK_7", GLFW_JOYSTICK_7);
	EXPORT_CONST("JOYSTICK_8", GLFW_JOYSTICK_8);
	EXPORT_CONST("JOYSTICK_9", GLFW_JOYSTICK_9);
	EXPORT_CONST("JOYSTICK_10", GLFW_JOYSTICK_10);
	EXPORT_CONST("JOYSTICK_11", GLFW_JOYSTICK_11);
	EXPORT_CONST("JOYSTICK_12", GLFW_JOYSTICK_12);
	EXPORT_CONST("JOYSTICK_13", GLFW_JOYSTICK_13);
	EXPORT_CONST("JOYSTICK_14", GLFW_JOYSTICK_14);
	EXPORT_CONST("JOYSTICK_15", GLFW_JOYSTICK_15);
	EXPORT_CONST("JOYSTICK_16", GLFW_JOYSTICK_16);
	EXPORT_CONST("JOYSTICK_LAST", GLFW_JOYSTICK_LAST);
	EXPORT_CONST("GAMEPAD_BUTTON_A", GLFW_GAMEPAD_BUTTON_A);
	EXPORT_CONST("GAMEPAD_BUTTON_B", GLFW_GAMEPAD_BUTTON_B);
	EXPORT_CONST("GAMEPAD_BUTTON_X", GLFW_GAMEPAD_BUTTON_X);
	EXPORT_CONST("GAMEPAD_BUTTON_Y", GLFW_GAMEPAD_BUTTON_Y);
	EXPORT_CONST("GAMEPAD_BUTTON_LEFT_BUMPER", GLFW_GAMEPAD_BUTTON_LEFT_BUMPER);
	EXPORT_CONST("GAMEPAD_BUTTON_RIGHT_BUMPER", GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER);
	EXPORT_CONST("GAMEPAD_BUTTON_BACK", GLFW_GAMEPAD_BUTTON_BACK);
	EXPORT_CONST("GAMEPAD_BUTTON_START", GLFW_GAMEPAD_BUTTON_START);
	EXPORT_CONST("GAMEPAD_BUTTON_GUIDE", GLFW_GAMEPAD_BUTTON_GUIDE);
	EXPORT_CONST("GAMEPAD_BUTTON_LEFT_THUMB", GLFW_GAMEPAD_BUTTON_LEFT_THUMB);
	EXPORT_CONST("GAMEPAD_BUTTON_RIGHT_THUMB", GLFW_GAMEPAD_BUTTON_RIGHT_THUMB);
	EXPORT_CONST("GAMEPAD_BUTTON_DPAD_UP", GLFW_GAMEPAD_BUTTON_DPAD_UP);
	EXPORT_CONST("GAMEPAD_BUTTON_DPAD_RIGHT", GLFW_GAMEPAD_BUTTON_DPAD_RIGHT);
	EXPORT_CONST("GAMEPAD_BUTTON_DPAD_DOWN", GLFW_GAMEPAD_BUTTON_DPAD_DOWN);
	EXPORT_CONST("GAMEPAD_BUTTON_DPAD_LEFT", GLFW_GAMEPAD_BUTTON_DPAD_LEFT);
	EXPORT_CONST("GAMEPAD_BUTTON_LAST", GLFW_GAMEPAD_BUTTON_LAST);
	EXPORT_CONST("GAMEPAD_BUTTON_CROSS", GLFW_GAMEPAD_BUTTON_CROSS);
	EXPORT_CONST("GAMEPAD_BUTTON_CIRCLE", GLFW_GAMEPAD_BUTTON_CIRCLE);
	EXPORT_CONST("GAMEPAD_BUTTON_SQUARE", GLFW_GAMEPAD_BUTTON_SQUARE);
	EXPORT_CONST("GAMEPAD_BUTTON_TRIANGLE", GLFW_GAMEPAD_BUTTON_TRIANGLE);
	EXPORT_CONST("GAMEPAD_AXIS_LEFT_X", GLFW_GAMEPAD_AXIS_LEFT_X);
	EXPORT_CONST("GAMEPAD_AXIS_LEFT_Y", GLFW_GAMEPAD_AXIS_LEFT_Y);
	EXPORT_CONST("GAMEPAD_AXIS_RIGHT_X", GLFW_GAMEPAD_AXIS_RIGHT_X);
	EXPORT_CONST("GAMEPAD_AXIS_RIGHT_Y", GLFW_GAMEPAD_AXIS_RIGHT_Y);
	EXPORT_CONST("GAMEPAD_AXIS_LEFT_TRIGGER", GLFW_GAMEPAD_AXIS_LEFT_TRIGGER);
	EXPORT_CONST("GAMEPAD_AXIS_RIGHT_TRIGGER", GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER);
	EXPORT_CONST("GAMEPAD_AXIS_LAST", GLFW_GAMEPAD_AXIS_LAST);
	EXPORT_CONST("NO_ERROR", GLFW_NO_ERROR);
	EXPORT_CONST("NOT_INITIALIZED", GLFW_NOT_INITIALIZED);
	EXPORT_CONST("NO_CURRENT_CONTEXT", GLFW_NO_CURRENT_CONTEXT);
	EXPORT_CONST("INVALID_ENUM", GLFW_INVALID_ENUM);
	EXPORT_CONST("INVALID_VALUE", GLFW_INVALID_VALUE);
	EXPORT_CONST("OUT_OF_MEMORY", GLFW_OUT_OF_MEMORY);
	EXPORT_CONST("API_UNAVAILABLE", GLFW_API_UNAVAILABLE);
	EXPORT_CONST("VERSION_UNAVAILABLE", GLFW_VERSION_UNAVAILABLE);
	EXPORT_CONST("PLATFORM_ERROR", GLFW_PLATFORM_ERROR);
	EXPORT_CONST("FORMAT_UNAVAILABLE", GLFW_FORMAT_UNAVAILABLE);
	EXPORT_CONST("NO_WINDOW_CONTEXT", GLFW_NO_WINDOW_CONTEXT);
	EXPORT_CONST("FOCUSED", GLFW_FOCUSED);
	EXPORT_CONST("ICONIFIED", GLFW_ICONIFIED);
	EXPORT_CONST("RESIZABLE", GLFW_RESIZABLE);
	EXPORT_CONST("VISIBLE", GLFW_VISIBLE);
	EXPORT_CONST("DECORATED", GLFW_DECORATED);
	EXPORT_CONST("AUTO_ICONIFY", GLFW_AUTO_ICONIFY);
	EXPORT_CONST("FLOATING", GLFW_FLOATING);
	EXPORT_CONST("MAXIMIZED", GLFW_MAXIMIZED);
	EXPORT_CONST("CENTER_CURSOR", GLFW_CENTER_CURSOR);
	EXPORT_CONST("TRANSPARENT_FRAMEBUFFER", GLFW_TRANSPARENT_FRAMEBUFFER);
	EXPORT_CONST("HOVERED", GLFW_HOVERED);
	EXPORT_CONST("FOCUS_ON_SHOW", GLFW_FOCUS_ON_SHOW);
	EXPORT_CONST("RED_BITS", GLFW_RED_BITS);
	EXPORT_CONST("GREEN_BITS", GLFW_GREEN_BITS);
	EXPORT_CONST("BLUE_BITS", GLFW_BLUE_BITS);
	EXPORT_CONST("ALPHA_BITS", GLFW_ALPHA_BITS);
	EXPORT_CONST("DEPTH_BITS", GLFW_DEPTH_BITS);
	EXPORT_CONST("STENCIL_BITS", GLFW_STENCIL_BITS);
	EXPORT_CONST("ACCUM_RED_BITS", GLFW_ACCUM_RED_BITS);
	EXPORT_CONST("ACCUM_GREEN_BITS", GLFW_ACCUM_GREEN_BITS);
	EXPORT_CONST("ACCUM_BLUE_BITS", GLFW_ACCUM_BLUE_BITS);
	EXPORT_CONST("ACCUM_ALPHA_BITS", GLFW_ACCUM_ALPHA_BITS);
	EXPORT_CONST("AUX_BUFFERS", GLFW_AUX_BUFFERS);
	EXPORT_CONST("STEREO", GLFW_STEREO);
	EXPORT_CONST("SAMPLES", GLFW_SAMPLES);
	EXPORT_CONST("SRGB_CAPABLE", GLFW_SRGB_CAPABLE);
	EXPORT_CONST("REFRESH_RATE", GLFW_REFRESH_RATE);
	EXPORT_CONST("DOUBLEBUFFER", GLFW_DOUBLEBUFFER);
	EXPORT_CONST("CLIENT_API", GLFW_CLIENT_API);
	EXPORT_CONST("CONTEXT_VERSION_MAJOR", GLFW_CONTEXT_VERSION_MAJOR);
	EXPORT_CONST("CONTEXT_VERSION_MINOR", GLFW_CONTEXT_VERSION_MINOR);
	EXPORT_CONST("CONTEXT_REVISION", GLFW_CONTEXT_REVISION);
	EXPORT_CONST("CONTEXT_ROBUSTNESS", GLFW_CONTEXT_ROBUSTNESS);
	EXPORT_CONST("OPENGL_FORWARD_COMPAT", GLFW_OPENGL_FORWARD_COMPAT);
	EXPORT_CONST("OPENGL_DEBUG_CONTEXT", GLFW_OPENGL_DEBUG_CONTEXT);
	EXPORT_CONST("OPENGL_PROFILE", GLFW_OPENGL_PROFILE);
	EXPORT_CONST("CONTEXT_RELEASE_BEHAVIOR", GLFW_CONTEXT_RELEASE_BEHAVIOR);
	EXPORT_CONST("CONTEXT_NO_ERROR", GLFW_CONTEXT_NO_ERROR);
	EXPORT_CONST("CONTEXT_CREATION_API", GLFW_CONTEXT_CREATION_API);
	EXPORT_CONST("SCALE_TO_MONITOR", GLFW_SCALE_TO_MONITOR);
	EXPORT_CONST("COCOA_RETINA_FRAMEBUFFER", GLFW_COCOA_RETINA_FRAMEBUFFER);
	EXPORT_CONST("COCOA_FRAME_NAME", GLFW_COCOA_FRAME_NAME);
	EXPORT_CONST("COCOA_GRAPHICS_SWITCHING", GLFW_COCOA_GRAPHICS_SWITCHING);
	EXPORT_CONST("X11_CLASS_NAME", GLFW_X11_CLASS_NAME);
	EXPORT_CONST("X11_INSTANCE_NAME", GLFW_X11_INSTANCE_NAME);
	EXPORT_CONST("NO_API", GLFW_NO_API);
	EXPORT_CONST("OPENGL_API", GLFW_OPENGL_API);
	EXPORT_CONST("OPENGL_ES_API", GLFW_OPENGL_ES_API);
	EXPORT_CONST("NO_ROBUSTNESS", GLFW_NO_ROBUSTNESS);
	EXPORT_CONST("NO_RESET_NOTIFICATION", GLFW_NO_RESET_NOTIFICATION);
	EXPORT_CONST("LOSE_CONTEXT_ON_RESET", GLFW_LOSE_CONTEXT_ON_RESET);
	EXPORT_CONST("OPENGL_ANY_PROFILE", GLFW_OPENGL_ANY_PROFILE);
	EXPORT_CONST("OPENGL_CORE_PROFILE", GLFW_OPENGL_CORE_PROFILE);
	EXPORT_CONST("OPENGL_COMPAT_PROFILE", GLFW_OPENGL_COMPAT_PROFILE);
	EXPORT_CONST("CURSOR", GLFW_CURSOR);
	EXPORT_CONST("STICKY_KEYS", GLFW_STICKY_KEYS);
	EXPORT_CONST("STICKY_MOUSE_BUTTONS", GLFW_STICKY_MOUSE_BUTTONS);
	EXPORT_CONST("LOCK_KEY_MODS", GLFW_LOCK_KEY_MODS);
	EXPORT_CONST("RAW_MOUSE_MOTION", GLFW_RAW_MOUSE_MOTION);
	EXPORT_CONST("CURSOR_NORMAL", GLFW_CURSOR_NORMAL);
	EXPORT_CONST("CURSOR_HIDDEN", GLFW_CURSOR_HIDDEN);
	EXPORT_CONST("CURSOR_DISABLED", GLFW_CURSOR_DISABLED);
	EXPORT_CONST("ANY_RELEASE_BEHAVIOR", GLFW_ANY_RELEASE_BEHAVIOR);
	EXPORT_CONST("RELEASE_BEHAVIOR_FLUSH", GLFW_RELEASE_BEHAVIOR_FLUSH);
	EXPORT_CONST("RELEASE_BEHAVIOR_NONE", GLFW_RELEASE_BEHAVIOR_NONE);
	EXPORT_CONST("NATIVE_CONTEXT_API", GLFW_NATIVE_CONTEXT_API);
	EXPORT_CONST("EGL_CONTEXT_API", GLFW_EGL_CONTEXT_API);
	EXPORT_CONST("OSMESA_CONTEXT_API", GLFW_OSMESA_CONTEXT_API);
	EXPORT_CONST("ARROW_CURSOR", GLFW_ARROW_CURSOR);
	EXPORT_CONST("IBEAM_CURSOR", GLFW_IBEAM_CURSOR);
	EXPORT_CONST("CROSSHAIR_CURSOR", GLFW_CROSSHAIR_CURSOR);
	EXPORT_CONST("HAND_CURSOR", GLFW_HAND_CURSOR);
	EXPORT_CONST("HRESIZE_CURSOR", GLFW_HRESIZE_CURSOR);
	EXPORT_CONST("VRESIZE_CURSOR", GLFW_VRESIZE_CURSOR);
	EXPORT_CONST("CONNECTED", GLFW_CONNECTED);
	EXPORT_CONST("DISCONNECTED", GLFW_DISCONNECTED);
	EXPORT_CONST("JOYSTICK_HAT_BUTTONS", GLFW_JOYSTICK_HAT_BUTTONS);
	EXPORT_CONST("COCOA_CHDIR_RESOURCES", GLFW_COCOA_CHDIR_RESOURCES);
	EXPORT_CONST("COCOA_MENUBAR", GLFW_COCOA_MENUBAR);
	EXPORT_CONST("DONT_CARE", GLFW_DONT_CARE);

    #pragma endregion
    // Methods
    #pragma region
	NODE_SET_METHOD(exports, "init", Init);
	NODE_SET_METHOD(exports, "terminate", Terminate);
	NODE_SET_METHOD(exports, "initHint", InitHint);
	NODE_SET_METHOD(exports, "getVersion", GetVersion);
	NODE_SET_METHOD(exports, "getVersionString", GetVersionString);
	NODE_SET_METHOD(exports, "getError", GetError);
	NODE_SET_METHOD(exports, "setErrorCallback", SetErrorCallback);
	NODE_SET_METHOD(exports, "getMonitors", GetMonitors);
	NODE_SET_METHOD(exports, "getPrimaryMonitor", GetPrimaryMonitor);
	NODE_SET_METHOD(exports, "getMonitorPos", GetMonitorPos);
	NODE_SET_METHOD(exports, "getMonitorWorkarea", GetMonitorWorkarea);
	NODE_SET_METHOD(exports, "getMonitorPhysicalSize", GetMonitorPhysicalSize);
	NODE_SET_METHOD(exports, "getMonitorContentScale", GetMonitorContentScale);
	NODE_SET_METHOD(exports, "getMonitorName", GetMonitorName);
	NODE_SET_METHOD(exports, "setMonitorUserPointer", SetMonitorUserPointer);
	NODE_SET_METHOD(exports, "getMonitorUserPointer", GetMonitorUserPointer);
	NODE_SET_METHOD(exports, "setMonitorCallback", SetMonitorCallback);
	NODE_SET_METHOD(exports, "getVideoModes", GetVideoModes);
	NODE_SET_METHOD(exports, "getVideoMode", GetVideoMode);
	NODE_SET_METHOD(exports, "setGamma", SetGamma);
	NODE_SET_METHOD(exports, "getGammaRamp", GetGammaRamp);
	NODE_SET_METHOD(exports, "setGammaRamp", SetGammaRamp);
	NODE_SET_METHOD(exports, "defaultWindowHints", DefaultWindowHints);
	NODE_SET_METHOD(exports, "windowHint", WindowHint);
	NODE_SET_METHOD(exports, "windowHintString", WindowHintString);
	NODE_SET_METHOD(exports, "createWindow", CreateWindow);
	NODE_SET_METHOD(exports, "destroyWindow", DestroyWindow);
	NODE_SET_METHOD(exports, "windowShouldClose", WindowShouldClose);
	NODE_SET_METHOD(exports, "setWindowShouldClose", SetWindowShouldClose);
	NODE_SET_METHOD(exports, "setWindowTitle", SetWindowTitle);
	NODE_SET_METHOD(exports, "setWindowIcon", SetWindowIcon);
	NODE_SET_METHOD(exports, "getWindowPos", GetWindowPos);
	NODE_SET_METHOD(exports, "setWindowPos", SetWindowPos);
	NODE_SET_METHOD(exports, "getWindowSize", GetWindowSize);
	NODE_SET_METHOD(exports, "setWindowSizeLimits", SetWindowSizeLimits);
	NODE_SET_METHOD(exports, "setWindowAspectRatio", SetWindowAspectRatio);
	NODE_SET_METHOD(exports, "setWindowSize", SetWindowSize);
	NODE_SET_METHOD(exports, "getFramebufferSize", GetFramebufferSize);
	NODE_SET_METHOD(exports, "getWindowFrameSize", GetWindowFrameSize);
	NODE_SET_METHOD(exports, "getWindowContentScale", GetWindowContentScale);
	NODE_SET_METHOD(exports, "getWindowOpacity", GetWindowOpacity);
	NODE_SET_METHOD(exports, "setWindowOpacity", SetWindowOpacity);
	NODE_SET_METHOD(exports, "iconifyWindow", IconifyWindow);
	NODE_SET_METHOD(exports, "restoreWindow", RestoreWindow);
	NODE_SET_METHOD(exports, "maximizeWindow", MaximizeWindow);
	NODE_SET_METHOD(exports, "showWindow", ShowWindow);
	NODE_SET_METHOD(exports, "hideWindow", HideWindow);
	NODE_SET_METHOD(exports, "focusWindow", FocusWindow);
	NODE_SET_METHOD(exports, "requestWindowAttention", RequestWindowAttention);
	NODE_SET_METHOD(exports, "getWindowMonitor", GetWindowMonitor);
	NODE_SET_METHOD(exports, "setWindowMonitor", SetWindowMonitor);
	NODE_SET_METHOD(exports, "getWindowAttrib", GetWindowAttrib);
	NODE_SET_METHOD(exports, "setWindowAttrib", SetWindowAttrib);
	NODE_SET_METHOD(exports, "setWindowUserPointer", SetWindowUserPointer);
	NODE_SET_METHOD(exports, "getWindowUserPointer", GetWindowUserPointer);
	NODE_SET_METHOD(exports, "setWindowPosCallback", SetWindowPosCallback);
	NODE_SET_METHOD(exports, "setWindowSizeCallback", SetWindowSizeCallback);
	NODE_SET_METHOD(exports, "setWindowCloseCallback", SetWindowCloseCallback);
	NODE_SET_METHOD(exports, "setWindowRefreshCallback", SetWindowRefreshCallback);
	NODE_SET_METHOD(exports, "setWindowFocusCallback", SetWindowFocusCallback);
	NODE_SET_METHOD(exports, "setWindowIconifyCallback", SetWindowIconifyCallback);
	NODE_SET_METHOD(exports, "setWindowMaximizeCallback", SetWindowMaximizeCallback);
	NODE_SET_METHOD(exports, "setFramebufferSizeCallback", SetFramebufferSizeCallback);
	NODE_SET_METHOD(exports, "setWindowContentScaleCallback", SetWindowContentScaleCallback);
	NODE_SET_METHOD(exports, "pollEvents", PollEvents);
	NODE_SET_METHOD(exports, "waitEvents", WaitEvents);
	NODE_SET_METHOD(exports, "waitEventsTimeout", WaitEventsTimeout);
	NODE_SET_METHOD(exports, "postEmptyEvent", PostEmptyEvent);
	NODE_SET_METHOD(exports, "getInputMode", GetInputMode);
	NODE_SET_METHOD(exports, "setInputMode", SetInputMode);
	NODE_SET_METHOD(exports, "rawMouseMotionSupported", RawMouseMotionSupported);
	NODE_SET_METHOD(exports, "getKeyName", GetKeyName);
	NODE_SET_METHOD(exports, "getKeyScancode", GetKeyScancode);
	NODE_SET_METHOD(exports, "getKey", GetKey);
	NODE_SET_METHOD(exports, "getMouseButton", GetMouseButton);
	NODE_SET_METHOD(exports, "getCursorPos", GetCursorPos);
	NODE_SET_METHOD(exports, "setCursorPos", SetCursorPos);
	NODE_SET_METHOD(exports, "createCursor", CreateCursor);
	NODE_SET_METHOD(exports, "createStandardCursor", CreateStandardCursor);
	NODE_SET_METHOD(exports, "destroyCursor", DestroyCursor);
	NODE_SET_METHOD(exports, "setCursor", SetCursor);
	NODE_SET_METHOD(exports, "setKeyCallback", SetKeyCallback);
	NODE_SET_METHOD(exports, "setCharCallback", SetCharCallback);
	NODE_SET_METHOD(exports, "setCharModsCallback", SetCharModsCallback);
	NODE_SET_METHOD(exports, "setMouseButtonCallback", SetMouseButtonCallback);
	NODE_SET_METHOD(exports, "setCursorPosCallback", SetCursorPosCallback);
	NODE_SET_METHOD(exports, "setCursorEnterCallback", SetCursorEnterCallback);
	NODE_SET_METHOD(exports, "setScrollCallback", SetScrollCallback);
	NODE_SET_METHOD(exports, "setDropCallback", SetDropCallback);
	NODE_SET_METHOD(exports, "joystickPresent", JoystickPresent);
	NODE_SET_METHOD(exports, "getJoystickAxes", GetJoystickAxes);
	NODE_SET_METHOD(exports, "getJoystickButtons", GetJoystickButtons);
	NODE_SET_METHOD(exports, "getJoystickHats", GetJoystickHats);
	NODE_SET_METHOD(exports, "getJoystickName", GetJoystickName);
	NODE_SET_METHOD(exports, "getJoystickGUID", GetJoystickGUID);
	NODE_SET_METHOD(exports, "setJoystickUserPointer", SetJoystickUserPointer);
	NODE_SET_METHOD(exports, "getJoystickUserPointer", GetJoystickUserPointer);
	NODE_SET_METHOD(exports, "joystickIsGamepad", JoystickIsGamepad);
	NODE_SET_METHOD(exports, "setJoystickCallback", SetJoystickCallback);
	NODE_SET_METHOD(exports, "updateGamepadMappings", UpdateGamepadMappings);
	NODE_SET_METHOD(exports, "getGamepadName", GetGamepadName);
	NODE_SET_METHOD(exports, "getGamepadState", GetGamepadState);
	NODE_SET_METHOD(exports, "setClipboardString", SetClipboardString);
	NODE_SET_METHOD(exports, "getClipboardString", GetClipboardString);
	NODE_SET_METHOD(exports, "getTime", GetTime);
	NODE_SET_METHOD(exports, "setTime", SetTime);
	NODE_SET_METHOD(exports, "getTimerValue", GetTimerValue);
	NODE_SET_METHOD(exports, "getTimerFrequency", GetTimerFrequency);
	NODE_SET_METHOD(exports, "makeContextCurrent", MakeContextCurrent);
	NODE_SET_METHOD(exports, "getCurrentContext", GetCurrentContext);
	NODE_SET_METHOD(exports, "swapBuffers", SwapBuffers);
	NODE_SET_METHOD(exports, "swapInterval", SwapInterval);
	NODE_SET_METHOD(exports, "extensionSupported", ExtensionSupported);
	NODE_SET_METHOD(exports, "getProcAddress", GetProcAddress);
	NODE_SET_METHOD(exports, "vulkanSupported", VulkanSupported);
	NODE_SET_METHOD(exports, "getRequiredInstanceExtensions", GetRequiredInstanceExtensions);
	NODE_SET_METHOD(exports, "getInstanceProcAddress", GetInstanceProcAddress);
	NODE_SET_METHOD(exports, "getPhysicalDevicePresentationSupport", GetPhysicalDevicePresentationSupport);
	NODE_SET_METHOD(exports, "createWindowSurface", CreateWindowSurface);

    #pragma endregion
}
NODE_MODULE(NODE_GYP_MODULE_NAME, ExportModule);